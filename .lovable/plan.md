
Цель: убрать “бесконечное Соединение” в звонках и сделать установку WebRTC устойчивой (без “повезло/не повезло”), объяснив причину проблемы понятным языком.

## Что происходит и почему “Соединение” может висеть бесконечно

Сейчас звонок устроен так:
1) В базе создаётся запись `calls` со статусом `calling`.
2) У получателя по realtime приходит INSERT → UI показывает входящий звонок → статус авто-обновляется на `ringing`.
3) Когда получатель нажимает “Ответить”, статус меняется на `active`.
4) Только при `active` CallScreen запускает WebRTC (`startCall()`).
5) WebRTC сигналинг (offer/answer/ICE candidates) пересылается через realtime broadcast канал `call:${callId}`.

Проблема “бесконечное соединение” чаще всего здесь:
- У нас есть гонка (race condition): канал realtime уже подписан, но обработчик входящих сигналов (`channel.on('broadcast'...)`) ставится только внутри `createPeer()`, а `createPeer()` вызывается после `getUserMedia()`.
- Если инициатор успевает отправить первый важный сигнал (обычно SDP offer) пока второй ещё запрашивает доступ к микрофону/камере (или просто тормозит устройство), этот сигнал теряется, потому что слушатель ещё не включён.
- В итоге обе стороны “ждут”, потому что одна сторона не получила offer/answer/ICE вовремя → соединение не может “схлопнуться” и остаётся в “connecting”.

Почему это выглядит как “иногда работает, иногда нет”:
- скорость получения `getUserMedia()` и скорость подписки/отрисовки на разных устройствах непредсказуемы;
- задержка 300ms/1500ms в CallScreen частично помогает, но не гарантирует (особенно на слабых телефонах/в плохой сети).

Дополнительные возможные причины (мы учтём их в доработке):
- payload лимиты/ошибки отправки broadcast (нужно логировать результат `channel.send()` и размер сигналов);
- отсутствие явного “handshake” (кто готов, кто начал);
- WebRTC может зависать на ICE (нужно корректно трекать и показывать состояние, и иметь “перезапуск” при таймауте).

## Что именно будем менять (без переделки всей архитектуры)

### 1) Вводим “handshake” готовности (ready/hello) перед обменом SDP
Идея: инициатор НЕ должен генерировать offer пока не уверен, что у второй стороны уже:
- подписан realtime канал,
- включён обработчик входящих сообщений,
- (опционально) уже создан peer или хотя бы готов принимать signals.

Как:
- После `setupSignaling()` обе стороны отправляют broadcast событие `ready`.
- Инициатор ждёт `ready` от второй стороны (с таймаутом, например 5–8 секунд).
- Только после получения `ready` инициатор создаёт Peer (то есть начинает генерацию offer).
- Получатель создаёт Peer сразу после подписки (или после получения local stream), но при этом уже точно слушает входящие сигналы.

Результат: первый offer не теряется.

### 2) Буферизация входящих сигналов до готовности peer
Даже с handshake полезно иметь “страховку”:
- Сразу после `setupSignaling()` ставим `channel.on('broadcast', event:'signal')` и складываем входящие сигналы в очередь `pendingSignalsRef`.
- Когда `peerRef.current` появляется — “прокачиваем” очередь в `peer.signal(...)`.

Это закрывает любые микрогонки: если сигнал прилетел раньше, чем peer создан — он не пропадёт.

### 3) Улучшаем диагностику и показываем “где именно зависло”
Добавим структурные логи (и при желании UI-индикатор):
- Подписка на канал: SUBSCRIBED/ERROR/TIMED_OUT
- Получили ready / отправили ready
- Получили signal (тип: offer/answer/candidate, размер)
- `channel.send()` результат (ошибка/ok)
- ICE state change / connection state change
- Таймауты: “не получили ready”, “не установили connect за 45 сек”

Так вы сможете дать человеку “инструкцию”, а я по логам буду видеть точку поломки.

### 4) Добавим “мягкий авто-retry” если connect не наступил
Если прошло, например, 15–20 секунд и мы не connected:
- завершить текущий peer,
- пересоздать signaling channel,
- повторить handshake и повторить старт (1 попытка, чтобы не уйти в бесконечный цикл).

Это сильно повышает шанс дозвониться в реальных сетях.

### 5) Опционально (если выяснится лимит broadcast по размеру)
Если по логам увидим, что:
- offer/answer слишком большой и `channel.send()` возвращает ошибку,
то варианты:
- перейти на `trickle: true` (уже включено) и убедиться что offer/answer не режется;
- если проблема именно в SDP размере — можно включить компрессию/чанкинг SDP (более сложно) или хранить offer/answer в таблице `call_signals` (БД) и отдавать через realtime postgres_changes (надежно, но потребует миграции и RLS).

Пока начнём с handshake + буфер. Обычно этого достаточно.

## Где в коде будем править

1) `src/hooks/useSimplePeerWebRTC.tsx`
- Добавить `ready` событие:
  - `channel.send({ event: 'ready', payload: { from: user.id } })`
  - слушатель `channel.on('broadcast', { event: 'ready' }, ...)`
- Добавить очередь `pendingSignalsRef`:
  - слушатель signal включать сразу после подписки (ещё до createPeer)
  - если peer ещё нет — push в очередь
  - после создания peer — применить все pending signals
- Добавить таймаут ожидания ready у инициатора
- Добавить проверку результата `channel.send()` (логировать ответ)
- Добавить retry-логику по таймауту (аккуратно, 1 попытка)

2) `src/components/chat/CallScreen.tsx`
- Минимально: оставить текущую логику старта по `call.status === "active"`, но:
  - уточнить отображение статуса: “Ожидание ответа” / “Соединение” / “Проблема соединения”
  - показывать понятное сообщение при таймауте (например “Не удалось установить соединение, попробуйте ещё раз”)

## Инструкция для человека (чтобы он помог диагностировать)
После внедрения логов вы просите человека:
1) Открыть звонок в двух аккаунтах (лучше 2 разных устройства или хотя бы 2 разных браузера/инкогнито).
2) Позвонить → принять → подождать 10–15 сек.
3) Если висит “Соединение”:
   - НЕ перезагружать страницу
   - прислать сюда:
     - скрин консоли (фильтр “[SimplePeer]”)
     - и время, когда нажал “Ответить”
Мы увидим: дошёл ли `ready`, дошёл ли offer/answer, есть ли ICE кандидаты, есть ли ошибки send.

## Критерии “готово”
- После принятия звонка:
  - обе стороны видят переход в connected за ~1–8 секунд (зависит от сети)
  - в логах есть последовательность: SUBSCRIBED → ready sent/received → signal offer/answer → ICE state progression → Connected
- Если сеть плохая:
  - таймаут выдаёт понятную ошибку + 1 автоповтор (или кнопка “Повторить”)

## Риски и что будем делать если не поможет
Если после handshake+буфера всё ещё “вечное соединение”, то по логам станет понятно:
- либо проблема в ICE (нужно форсировать TURN/relay policy или чинить ICE сервера),
- либо в ограничениях realtime broadcast (тогда перейдём на хранение сигналов в БД + realtime postgres_changes),
- либо проблема устройства/браузера (Safari iOS часто требует особого внимания к autoplay/permissions).
